---
import Layout from '../layouts/Layout.astro';
---

<Layout title="Encryption" description="Encryption adapters for SwirlDB - at-rest and over-the-wire protection">
  <h1>Encryption</h1>

  <p>
    SwirlDB provides pluggable encryption at multiple levels through the <code>EncryptionProvider</code> trait.
    All encryption works on all platforms (browser + server).
  </p>

  <section class="philosophy">
    <h2>Encryption Architecture</h2>
    <div class="card highlight">
      <h3>Encryption Layers</h3>
      <ul>
        <li><strong>At-Rest Encryption:</strong> Data encrypted before storage (localStorage, IndexedDB, redb)</li>
        <li><strong>Over-the-Wire:</strong> CRDT changes encrypted during sync between clients</li>
        <li><strong>Field-Level:</strong> Selective encryption based on field patterns</li>
      </ul>
    </div>
  </section>

  <section>
    <h2>Built-in Providers</h2>

    <div class="card">
      <h3>UnencryptedProvider (Default)</h3>
      <p>
        No-op provider that passes data through unchanged. Use when encryption is handled
        externally (encrypted filesystem, TLS, etc.) or not required.
      </p>
      <pre><code>{`// Rust
use swirldb_core::encryption::UnencryptedProvider;

let provider = UnencryptedProvider::new();

// TypeScript
const provider = new UnencryptedProvider();`}</code></pre>
    </div>

    <div class="card">
      <h3>AesGcmProvider (AES-256-GCM)</h3>
      <p>
        Authenticated encryption with 256-bit keys. Provides confidentiality and authenticity.
      </p>
      <pre><code>{`// Rust
use swirldb_core::encryption::AesGcmProvider;

// Random key
let provider = AesGcmProvider::new_random();

// Fixed key (32 bytes)
let key = [0u8; 32]; // In production: use secure random
let provider = AesGcmProvider::new(&key);

// Derive from password
let provider = AesGcmProvider::from_password(
    b"user-password",
    b"unique-salt-12345"
).unwrap();

// TypeScript
const provider = await AesGcmProvider.fromPassword('password', 'salt');`}</code></pre>
    </div>

    <div class="card">
      <h3>FieldEncryptionProvider</h3>
      <p>
        Pattern-based selective encryption. Encrypts matching fields while leaving others in plaintext.
      </p>
      <pre><code>{`// Rust
use swirldb_core::encryption::{FieldEncryptionProvider, AesGcmProvider};

let mut provider = FieldEncryptionProvider::new();

// Encrypt all SSN fields
provider.add_pattern("*.ssn", Box::new(AesGcmProvider::new_random()));

// Encrypt all password fields
provider.add_pattern("user.*.password", Box::new(AesGcmProvider::new_random()));

// Everything else remains unencrypted`}</code></pre>
    </div>
  </section>

  <section>
    <h2>Encryption At Rest</h2>

    <div class="card highlight">
      <h3>Browser Example</h3>
      <pre><code>{`import { SwirlDB, AesGcmProvider } from '@swirldb/js';

// Create encrypted storage
const encryption = await AesGcmProvider.fromPassword(
  'user-password',
  'app-salt'
);

const db = await SwirlDB.withLocalStorage('my-app', {
  encryption
});

// All data automatically encrypted before localStorage
db.data.user.ssn = '123-45-6789';  // Encrypted in storage
db.data.user.name = 'Alice';        // Encrypted in storage`}</code></pre>
    </div>

    <div class="card highlight">
      <h3>Server Example</h3>
      <pre><code>{`use swirldb_core::{SwirlDB, encryption::AesGcmProvider};
use swirldb_server::storage::RedbAdapter;

// Create encrypted storage
let encryption = AesGcmProvider::new_random();
let storage = RedbAdapter::new("./data")
    .with_encryption(encryption);

let db = SwirlDB::with_storage(storage, "db-key").await;

// All saves encrypted on disk
db.set_path("user.ssn", "123-45-6789".into())?;
db.persist().await?;  // Encrypted to redb`}</code></pre>
    </div>
  </section>

  <section>
    <h2>Encryption Over the Wire</h2>

    <p>
      For end-to-end encrypted sync, wrap CRDT changes before transmission.
      The server never sees plaintext data.
    </p>

    <div class="card">
      <h3>Encrypted Sync Example</h3>
      <pre><code>{`use swirldb_core::encryption::AesGcmProvider;

// Shared encryption key (use key exchange in production)
let sync_key = [0u8; 32];
let provider = AesGcmProvider::new(&sync_key);

// Get local changes
let changes = db.get_changes();

// Encrypt each change
let encrypted_changes: Vec<Vec<u8>> = changes
    .iter()
    .map(|change| provider.encrypt(change).await.unwrap())
    .collect();

// Send encrypted changes to server
sync_client.push(encrypted_changes).await?;`}</code></pre>
    </div>

    <div class="card highlight">
      <h3>Architecture</h3>
      <pre><code>{`┌─────────┐                           ┌─────────┐
│ Client  │                           │ Server  │
│         │                           │         │
│  CRDT   │                           │  CRDT   │
│    ↓    │                           │    ↓    │
│ Encrypt │ ──── Encrypted Wire ────→ │ Decrypt │
│    ↓    │                           │    ↓    │
│ Storage │                           │ Storage │
└─────────┘                           └─────────┘

Server never sees plaintext data`}</code></pre>
    </div>
  </section>

  <section>
    <h2>Security Best Practices</h2>

    <div class="card">
      <h3>Key Management</h3>
      <ul>
        <li><strong>Browser:</strong> Store keys in IndexedDB, protect with Web Crypto API</li>
        <li><strong>Server:</strong> Store keys in secure vault (HashiCorp Vault, AWS KMS)</li>
        <li><strong>Never:</strong> Hard-code keys in source code or commit to git</li>
      </ul>
    </div>

    <div class="card">
      <h3>Nonce Reuse</h3>
      <p>
        AES-GCM uses random nonces per encryption. <strong>Never reuse nonces with the same key.</strong>
        SwirlDB automatically generates fresh nonces for each encryption operation.
      </p>
    </div>

    <div class="card">
      <h3>Authentication</h3>
      <p>
        AES-GCM provides authenticated encryption (AEAD). Tampering with ciphertext will
        fail decryption. This protects against data corruption and malicious modification.
      </p>
    </div>

    <div class="card">
      <h3>Performance</h3>
      <ul>
        <li>AES-GCM throughput: ~1GB/s on modern hardware</li>
        <li>Field-level encryption encrypts only matching fields</li>
        <li>Transport encryption (TLS/WSS) provides additional protection</li>
        <li>Encryption overhead: typically <5% for document operations</li>
      </ul>
    </div>
  </section>

  <section>
    <h2>Future Enhancements</h2>
    <ul>
      <li>X25519 key exchange for multi-party encryption</li>
      <li>RSA-OAEP for asymmetric encryption</li>
      <li>Automatic key rotation support</li>
      <li>Hardware security module (HSM) integration</li>
      <li>Pattern matching for field-level encryption</li>
    </ul>
  </section>
</Layout>

<style>
  .card {
    background: white;
    border: 1px solid #e1e1e1;
    border-radius: 8px;
    padding: 1.5rem;
    margin: 1rem 0;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  }

  .card.highlight {
    border-left: 4px solid #667eea;
    background: #f9f9ff;
    padding: 2rem;
  }

  .philosophy {
    margin: 2rem 0;
  }

  ul {
    margin-left: 2rem;
    margin-top: 0.5rem;
  }

  li {
    margin: 0.5rem 0;
  }

  section {
    margin: 3rem 0;
  }
</style>
